package main

//go:generate go run generate.go
//go:generate gofmt -w generated/reply_codes.go

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/pkg/errors"
)

const (
	header = `// Code generated by replycodes/generate.go; DO NOT EDIT.
package replycodes`
	footer = `
func (e ReplyCode) Type() ReplyType {
  return ReplyType(e / 1000)
  }`
	replyCodesURL = "https://gitlab.nic.cz/labs/bird/-/raw/master/doc/reply_codes"
)

var (
	replyTypesPattern    = regexp.MustCompile(`(\d)xxx\s+(.+)`)
	replyCodesPattern    = regexp.MustCompile(`(\d{4})\s+(.+)`)
	nonAlphanumericRegex = regexp.MustCompile(`[^a-zA-Z0-9]+`)
)

func format(s string) string {
	return strcase.ToCamel(nonAlphanumericRegex.ReplaceAllString(s, "_"))
}

type Stringable interface {
	Format() string
	String() string
	Value() any
}

type Enum[T Stringable] []T

func (e Enum[T]) String() string {
	sb := strings.Builder{}
	name := reflect.TypeFor[T]().Elem().Name()
	sb.WriteString(fmt.Sprintf("type %s int\n\n", name))
	sb.WriteString("const (\n")
	for _, enumValue := range e {
		sb.WriteString(fmt.Sprintf("%s%s %s = %v\n", enumValue.Format(), name, name, enumValue.Value()))
	}
	sb.WriteString(")\n\n")
	sb.WriteString(fmt.Sprintf("func (e %s) String() string {\n", name))
	sb.WriteString("switch e {\n")
	for _, enumValue := range e {
		sb.WriteString(fmt.Sprintf("case %s%s:\n", enumValue.Format(), name))
		sb.WriteString(fmt.Sprintf("return \"%s\"\n", enumValue.String()))
	}
	sb.WriteString("}\n")
	sb.WriteString("return \"Unknown\"\n")
	sb.WriteString("}\n\n")
	return sb.String()
}

type ReplyType struct {
	Digit       int
	Description string
}

func (r *ReplyType) Format() string {
	return format(r.Description)
}

func (r *ReplyType) String() string {
	return r.Description
}

func (r *ReplyType) Value() any {
	return r.Digit
}

type ReplyCode struct {
	Code        int
	Description string
}

func (r *ReplyCode) Format() string {
	return format(r.Description)
}

func (r *ReplyCode) String() string {
	return r.Description
}

func (r *ReplyCode) Value() any {
	return r.Code
}

func parse(content string) (Enum[*ReplyType], Enum[*ReplyCode]) {
	lines := strings.Split(content, "\n")
	replyTypes := Enum[*ReplyType]{}
	replyCodes := Enum[*ReplyCode]{}
	for _, line := range lines {
		if replyTypesPattern.MatchString(line) {
			matches := replyTypesPattern.FindStringSubmatch(line)
			digit, _ := strconv.Atoi(matches[1])
			description := strings.TrimSpace(matches[2])
			replyTypes = append(replyTypes, &ReplyType{Digit: digit, Description: description})
		} else if replyCodesPattern.MatchString(line) {
			matches := replyCodesPattern.FindStringSubmatch(line)
			code, _ := strconv.Atoi(matches[1])
			description := strings.TrimSpace(matches[2])
			replyCodes = append(replyCodes, &ReplyCode{Code: code, Description: description})
		} else if len(line) > 0 {
			fmt.Println("Unknown line format:", line)
		}
	}
	return replyTypes, replyCodes
}

func generate(content []byte, output string) error {
	sb := strings.Builder{}
	sb.WriteString(header + "\n")

	replyTypes, replyCodes := parse(string(content))
	sb.WriteString(replyTypes.String())
	sb.WriteString(replyCodes.String())
	sb.WriteString("\n" + footer)

	err := os.WriteFile(output, []byte(sb.String()), 0o644)
	if err != nil {
		return errors.Wrapf(err, "failed to write to file: %s", output)
	}
	return nil
}

func fetch() ([]byte, error) {
	resp, err := http.Get(replyCodesURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, errors.Errorf("failed to fetch reply codes: %s", resp.Status)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return body, nil
}

func main() {
	fmt.Println("Fetching reply codes from", replyCodesURL)
	content, err := fetch()
	if err != nil {
		panic(err)
	}

	fmt.Println("Fetched", len(content), "bytes")
	fmt.Println("Generating reply_codes.go...")

	err = generate(content, "generated/reply_codes.go")
	if err != nil {
		panic(err)
	}
}
